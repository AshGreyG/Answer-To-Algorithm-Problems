---
tags:
  - computer-science
  - algorithm
  - algorithm-dp
  - algorithm-knapsack-dp
  - python
date: 2025-11-25
---

# 洛谷 P1164 背包dp | Python Week

## 1 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(0 < M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(1 \le N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(0 < a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。

### 1.1 输入格式

第一行两个整数 $N$ 和 $M$，分别表示菜品种类和 uim 身上的钱数。

第二行 $N$ 个正整数 $a_i$（可能有重复），用空格隔开，分别表示每种菜的价格。

### 1.2 输出格式

一个正整数，表示点菜方案数，保证答案的范围在 $[0,2^{31}-1]$ 之内（不超过 C/C++的 int 范围）。

### 1.3 输入输出样例 #1

#### 1.3.1 输入 #1

```
4 4
1 1 2 2
```

#### 1.3.2 输出 #1

```
3
```

### 1.4 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 2 分析

### 2.1 题面分析

本题属于 Knapsack dp （背包 dp 问题）的一种，因为所有菜肴都只能选择
最多一次，所以详细地来说，该问题属于 0/1 背包 dp 问题，每个物品只有
选择或者不被选择的选项。这类问题比较好的解决办法是构建状态转移方程，
首先题目中存在两个参数：金额总量 $j$ 与菜肴数量 $i$，而菜肴具体的价钱
并不适合作为状态转移的参数，所以我们只构建关于 $i,j$ 的状态转移方程。

考虑当前的状态与以往哪些状态有关系。我们关注新增的菜肴，编号为 $i$ 的
这道。我们什么时候能够购买这道菜肴呢？当我们所拥有的钱大于或者等于这道
菜肴的价格时。如果我们现在拥有的钱恰好等于菜肴的价格时，购买方案数就会
增加 $1$，即当 $j=\text{foods}[i]$ 时（设 $\text{foods}[0..n-1]$ 为
菜肴的价格表），我们有 $\text{dp}[i][j] = \text{dp}[i-1][j] + 1$。当
我们现在拥有的钱要大于当前菜肴的价格，买下当前菜肴之后还剩下
$j - \text{foods}[i]$，由于我们的状态转移是递推的，递推过程中金额 $j$
之前的方案数一定已经被计算过了，因此可以放心得到当 $j>\text{foods}[i]$
时有 

$$
\text{dp}[i][j]=\text{dp}[i-1][j]+\text{dp}[i-1][j-\text{foods}[i]]
$$

而当我们现在拥有的钱不足购买新增的菜肴时，自然就没有新增的购买方案了，
于是当 $j < \text{foods}[i]$ 时有 $\text{dp}[i][j]=\text{dp}[i-1][j]$。

### 2.2 算法实现-动态规划

根据上述分析我们可以很快得到算法实现

``` python
if __name__ == "__main__" :
    n, m = tuple(map(int, input().rstrip().split(" ")))
    foods = list(map(int, input().rstrip().split(" ")))
    dp : List[List[int]] = []

    for _ in range(n + 1) :
        row = []
        for _ in range(m + 1) :
            row.append(0)
        dp.append(row)

    for i in range(1, n + 1) :
        for j in range(1, m + 1) :
            if j == foods[i - 1] :
                dp[i][j] = dp[i - 1][j] + 1
            elif j > foods[i - 1] :
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - foods[i - 1]]
            else :
                dp[i][j] = dp[i - 1][j]

    print(dp[n][m])
```